<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Project Ideas</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-03-29 23:59:54 CET"/>
<meta name="author" content="pkhuong"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">Project Ideas</h1>

<p>This page provides an overview of a few projects that seem doable over
the course of approximately two months of thinking and programming,
for someone who isn't yet acquainted with our code base. The list
might seem long and daunting, the hope is that any single one of the
projects would prove to be an interesting, but solvable,
challenge. Moreover, we expect the projects to lead to tangible
results quickly (after a couple days or two weeks of hacking at most),
and that the goals could be extended in challenging and exciting
directions as more milestones will be reached.
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Improvements to the library </a>
<ul>
<li><a href="#sec-1.1">1.1 Unicode Integration </a></li>
<li><a href="#sec-1.2">1.2 Exploiting GMP for bignum and rational arithmetic </a></li>
<li><a href="#sec-1.3">1.3 Flexible (pseudo) random number generation </a></li>
<li><a href="#sec-1.4">1.4 Vectorised sequence operations </a></li>
<li><a href="#sec-1.5">1.5 More efficient hash functions and hash tables </a></li>
<li><a href="#sec-1.6">1.6 Efficient interpretation </a></li>
<li><a href="#sec-1.7">1.7 Improving the thread-safety of the object system </a></li>
<li><a href="#sec-1.8">1.8 Threading/locking debugging facilities </a></li>
</ul>
</li>
<li><a href="#sec-2">2 High-level optimisation </a>
<ul>
<li><a href="#sec-2.1">2.1 Efficient integer truncate/floor/ceiling by constants </a></li>
<li><a href="#sec-2.2">2.2 Exploiting switch/case in standard control structures </a></li>
</ul>
</li>
<li><a href="#sec-3">3 Middle end infrastructure </a>
<ul>
<li><a href="#sec-3.1">3.1 Accurate and correct numeric type derivation </a></li>
<li><a href="#sec-3.2">3.2 Expression optimisation </a></li>
<li><a href="#sec-3.3">3.3 Coarser type derivation system </a></li>
<li><a href="#sec-3.4">3.4 Quick compilation </a></li>
<li><a href="#sec-3.5">3.5 Precise type derivation </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Back end work </a>
<ul>
<li><a href="#sec-4.1">4.1 Modernising a graph-colouring register allocator </a></li>
<li><a href="#sec-4.2">4.2 Selecting concrete representations cleverly </a></li>
<li><a href="#sec-4.3">4.3 Peephole optimisation </a></li>
</ul>
</li>
<li><a href="#sec-5">5 Diving in the runtime system </a>
<ul>
<li><a href="#sec-5.1">5.1 Simpler structure layout </a></li>
<li><a href="#sec-5.2">5.2 Software write barriers </a></li>
<li><a href="#sec-5.3">5.3 Improving SBCL's memory allocator </a></li>
<li><a href="#sec-5.4">5.4 Garbage collection debugging and heap assertions </a></li>
<li><a href="#sec-5.5">5.5 A hybrid copying/mark-and-sweep garbage collector </a></li>
<li><a href="#sec-5.6">5.6 Replacing the garbage collector with MPS </a></li>
</ul>
</li>
<li><a href="#sec-6">6 Projects that may be further described if there is interest </a>
<ul>
<li><a href="#sec-6.1">6.1 Free-er form displaced arrays </a></li>
<li><a href="#sec-6.2">6.2 Autodxification of higher-order functions </a></li>
<li><a href="#sec-6.3">6.3 Better failure modes for heap overflow </a></li>
<li><a href="#sec-6.4">6.4 Inline caches for PCL </a></li>
<li><a href="#sec-6.5">6.5 clang(++)-based FFI </a></li>
<li><a href="#sec-6.6">6.6 MPFR for long floats </a></li>
<li><a href="#sec-6.7">6.7 Structured codewalking </a></li>
<li><a href="#sec-6.8">6.8 Hygienic macros </a></li>
<li><a href="#sec-6.9">6.9 Precompilation support for CLOS </a></li>
<li><a href="#sec-6.10">6.10 CLOS sealing </a></li>
<li><a href="#sec-6.11">6.11 GCed special variables </a></li>
<li><a href="#sec-6.12">6.12 Precise stack scanning </a></li>
<li><a href="#sec-6.13">6.13 A binary serialisation library </a></li>
<li><a href="#sec-6.14">6.14 Contracts </a></li>
<li><a href="#sec-6.15">6.15 Core relocation </a></li>
<li><a href="#sec-6.16">6.16 Reducing the size of delivered applications </a></li>
<li><a href="#sec-6.17">6.17 Unboxed calling convention </a></li>
<li><a href="#sec-6.18">6.18 Allocation pools </a></li>
<li><a href="#sec-6.19">6.19 Shared memory multi-process heap </a></li>
<li><a href="#sec-6.20">6.20 Faster FASL loading </a></li>
<li><a href="#sec-6.21">6.21 Scheduling pass </a></li>
<li><a href="#sec-6.22">6.22 utf-8b </a></li>
<li><a href="#sec-6.23">6.23 Parametric recursive types </a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Improvements to the library </h2>
<div class="outline-text-2" id="text-1">

<p>This section contains projects for which the work lies mainly in
improving the library of functions that are offered to users of SBCL.
</p>

</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1"><span class="section-number-3">1.1</span> Unicode Integration </h3>
<div class="outline-text-3" id="text-1.1">

<p>SBCL has a simple-minded implementation of Unicode support: each
Unicode codepoint is a single Lisp character, and strings are
sequences of codepoints. This implementation meets the principle of
least surprise, but has left some rough edges; the project here
involves exploring some of those rough edges and smoothing them
down. The project involves: implementation and testing (from test
vectors and differentially) of a number of Unicode algorithms, and
(the interesting bit) integrating those algorithms in a tasteful way
in the language runtime: for example, by using the normalization
algorithm in symbol equality, allowing easy use of collation keys for
sorting, or syllable breaking in the pretty-printer or formatter.
</p>

</div>

<div id="outline-container-1.1.1" class="outline-4">
<h4 id="sec-1.1.1"><span class="section-number-4">1.1.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.1.1">

<ol>
<li>
CL implementations of algorithms specified in the Unicode standards;
</li>
<li>
Integration of these algorithms into the the SBCL language runtime;
</li>
<li>
Integration of test cases into the SBCL build sequence;
</li>
<li>
Exploratory work in <i>using</i> these algorithms in suitable places in
the Lisp language runtime.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.1.2" class="outline-4">
<h4 id="sec-1.1.2"><span class="section-number-4">1.1.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.1.2">

<p>There are no hard prerequisites for this project; an interest in
internationalization issues would be helpful, as would prior
experience with working with Unicode.
</p>
</div>

</div>

<div id="outline-container-1.1.3" class="outline-4">
<h4 id="sec-1.1.3"><span class="section-number-4">1.1.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.1.3">

<p>A student successfully executing this project would learn about: data
structures for efficient information storage; test methodologies; and
working within the strictures of standardized algorithms and
languages.
</p>
</div>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2"><span class="section-number-3">1.2</span> Exploiting GMP for bignum and rational arithmetic </h3>
<div class="outline-text-3" id="text-1.2">

<p>SBCL has a reasonably simple but decent implementation of arbitrary
precision integers and rationals; its design is also informed by the
Common Lisp specification, in particular support for bitwise operation
in two's complement.  GNU MP (GMP) offers sophisticated routines that
would be extremely useful when working with medium and large bignums
or rationals, but calls to GMP entails conversion to/from
sign-magnitude representation, and foreign function interface
overhead.  The project requires the integration of GMP in SBCL,
ideally as an optional module ("contrib"), the development of
efficient conversion algorithms between GMP's and SBCL's concrete
representations, and the determination of cross-over points between
SBCL's and GMP's routines.  This work would probably be appreciated by
symbolic computing applications (e.g. maxima).
</p>

</div>

<div id="outline-container-1.2.1" class="outline-4">
<h4 id="sec-1.2.1"><span class="section-number-4">1.2.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.2.1">

<ol>
<li>
(partial) Foreign function interface definitions for GMP;
</li>
<li>
Development of routines to convert between two's complement and
sign-magnitude representation;
</li>
<li>
Integration in SBCL's existing bignum and rational arithmetic code;
</li>
<li>
Determination of criteria for the use of GMP's routines to improve
performance on large integer or rationals, as used in applications,
without overly penalising the common case of tiny values;
</li>
<li>
Development of unit tests for the new routines;
</li>
<li>
Improvement of SBCL's algorithms for small or medium bignums and
rationals (optional).

</li>
</ol>
</div>

</div>

<div id="outline-container-1.2.2" class="outline-4">
<h4 id="sec-1.2.2"><span class="section-number-4">1.2.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.2.2">

<p>Familiarity with Common Lisp or C. An interest in number theory would
be useful, and may provide additional motivation.
</p>
</div>

</div>

<div id="outline-container-1.2.3" class="outline-4">
<h4 id="sec-1.2.3"><span class="section-number-4">1.2.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.2.3">

<p>The student would learn to characterise the use of a small part of a
system (bignum and rational arithmetic) by various applications, and
develop microbenchmarks accordingly, in order to make non-obvious
technical decisions.  They would also exercise test methodologies, and
potentially implement algorithms described by specialised scientific
literature.
</p>
</div>
</div>

</div>

<div id="outline-container-1.3" class="outline-3">
<h3 id="sec-1.3"><span class="section-number-3">1.3</span> Flexible (pseudo) random number generation </h3>
<div class="outline-text-3" id="text-1.3">

<p>SBCL's support for random number generation is limited to an
implementation of the Mersenne Twister (MT19937) PRNG.  This is a good
general-purpose PRNG, but some applications require different
characteristics of the random numbers, whether that is specific
guarantees about correlations, suitability for cryptographic
algorithms, or just plain raw speed.  This project involves
implementing several PRNG algorithms, and integrating them into SBCL
in such a way as to allow library authors and end-users to
programmatically negotiate the choice of PRNG algorithm among multiple
implemented choices.
</p>

</div>

<div id="outline-container-1.3.1" class="outline-4">
<h4 id="sec-1.3.1"><span class="section-number-4">1.3.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.3.1">

<ol>
<li>
Implementations of several classes of random number generators,
including one statistically-robust PRNG, geared toward demanding
mathematical applications, and one believed suitable for
cryptographic applications;
</li>
<li>
Use of statistical tests to examine the properties of the
implemented PRNGs;
</li>
<li>
Pluggable integration into SBCL's existing random number generation
code (using random-state objects);
</li>
<li>
(optional) support for hardware random number generators;
</li>
<li>
(optional) development of a protocol to allow random number
generators to be selected dynamically given algorithmic
requirements.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.3.2" class="outline-4">
<h4 id="sec-1.3.2"><span class="section-number-4">1.3.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.3.2">

<p>No strict prerequisites, although some understanding of the possible
space of pseudorandom number generation, including tradeoffs regarding
speed, predictability (forwards and backwards) and dimensional
distribution.  Familiarity with CL and its approach to random number
generation can be acquired while doing the project.
</p>
</div>

</div>

<div id="outline-container-1.3.3" class="outline-4">
<h4 id="sec-1.3.3"><span class="section-number-4">1.3.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.3.3">

<p>The student will learn the breadth of possible implementations of
random number generators, and their limitations, all while working in
the context of an established language runtime.  A successful project
is also likely to cover statistical tests of randomness and efficient
object-oriented design.
</p>
</div>
</div>

</div>

<div id="outline-container-1.4" class="outline-3">
<h3 id="sec-1.4"><span class="section-number-3">1.4</span> Vectorised sequence operations </h3>
<div class="outline-text-3" id="text-1.4">

<p>SBCL is finally gaining support for x86-64 short vector SIMD
instructions (SSE), at the source level.  Many array and sequence
processing functions would benefit from manual vectorisation.  If
successful, this project would require the identification of manual
vectorisation targets, the development of efficient routines, and the
addition of code and of transformations in the compiler to exploit
these routines transparently.
</p>

</div>

<div id="outline-container-1.4.1" class="outline-4">
<h4 id="sec-1.4.1"><span class="section-number-4">1.4.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.4.1">

<ol>
<li>
A list of promising vectorisable operations;
</li>
<li>
The implementation of a few special cases for such vectorisable
operations;
</li>
<li>
A generic method to dispatch to vectorised routines depending on
the CPU's capabilities;
</li>
<li>
(optional) Convenience macros and functions to implement complete
vectorised operations, including misaligned data;
</li>
<li>
(optional) SIMD-within-a-register (SWAR) implementations for some
vectoriable routines.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.4.2" class="outline-4">
<h4 id="sec-1.4.2"><span class="section-number-4">1.4.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.4.2">

<p>Understanding of the bit-level representation of data in computers.
Familiarity with SSE instructions is expected to improve with time.
</p>
</div>

</div>

<div id="outline-container-1.4.3" class="outline-4">
<h4 id="sec-1.4.3"><span class="section-number-4">1.4.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.4.3">

<p>The student will learn to detect opportunities for vectorisation in
pre-existing code.  They will also hone their ability to adapt
algorithms to vector processing, and develop methods to determine when
and how operations should be vectorised.
</p>
</div>
</div>

</div>

<div id="outline-container-1.5" class="outline-3">
<h3 id="sec-1.5"><span class="section-number-3">1.5</span> More efficient hash functions and hash tables </h3>
<div class="outline-text-3" id="text-1.5">

<p>As mandated by the standard, SBCL offers hash tables and exposes
pre-defined hash functions.  Interactions with other parts of the
system make it challenging to improve general-purpose hash tables.
However, type-specialised hash tables seem approachable, as does
improving the quality of the standard hash functions.  If completed,
this project would lead to the implementation of better hash
functions, standard or as extensions, and to the development of
specialised associative dictionaries.
</p>

</div>

<div id="outline-container-1.5.1" class="outline-4">
<h4 id="sec-1.5.1"><span class="section-number-4">1.5.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.5.1">

<ol>
<li>
Adapt and implement known families of hash functions for integer
and string data;
</li>
<li>
Improve the distribution of standard hash functions;
</li>
<li>
Implement routines to test the quality and correctness of hash
functions;
</li>
<li>
(optional) Provide parameterised hash functions that are resistant to
collision attacks, as extensions to the standard;
</li>
<li>
(optional) Implement specialised associative dictionaries.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.5.2" class="outline-4">
<h4 id="sec-1.5.2"><span class="section-number-4">1.5.2</span> Prerequisite </h4>
<div class="outline-text-4" id="text-1.5.2">

<p>Familiarity with probabilities and with basic data structures.  An
interest in computer microarchitecture will be useful.
</p>
</div>

</div>

<div id="outline-container-1.5.3" class="outline-4">
<h4 id="sec-1.5.3"><span class="section-number-4">1.5.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.5.3">

<p>The student would exploit or implement state of the art hash
functions, compare their strengths and weaknesses, and integrate them
in a complete system.  They would also apply their understanding of
the low-level representation of data to develop specialised data
structures that remain compatible with a specification.
</p>
</div>
</div>

</div>

<div id="outline-container-1.6" class="outline-3">
<h3 id="sec-1.6"><span class="section-number-3">1.6</span> Efficient interpretation </h3>
<div class="outline-text-3" id="text-1.6">

<p>SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
efficient interpretation, an intermediate choice between the current
extremes of a full type-propagating compiler and an s-expression
interpreter.  Completion of this project entails the development of a
standard-compliant minimal compiler.
</p>

</div>

<div id="outline-container-1.6.1" class="outline-4">
<h4 id="sec-1.6.1"><span class="section-number-4">1.6.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.6.1">

<ol>
<li>
Disentangle or replicate the front-end to perform minimal
compilation;
</li>
<li>
Define an intermediate representation appropriate for the
efficient interpretation of Common Lisp code;
</li>
<li>
Develop a compiler from minimally-compiled source to the
intermediate representation.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.6.2" class="outline-4">
<h4 id="sec-1.6.2"><span class="section-number-4">1.6.2</span> Prerequisite </h4>
<div class="outline-text-4" id="text-1.6.2">

<p>Familiarity with Lisp macros and with first-class functions.
</p>
</div>

</div>

<div id="outline-container-1.6.3" class="outline-4">
<h4 id="sec-1.6.3"><span class="section-number-4">1.6.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.6.3">

<p>The student would improve their ability to read, understand, and
implement an ANSI standard.  They would then explore the performance
of a few standard or novel interpretation schemes on contemporary
computers.  Finally, they would develop a small compiler for a
practical programming language.
</p>
</div>
</div>

</div>

<div id="outline-container-1.7" class="outline-3">
<h3 id="sec-1.7"><span class="section-number-3">1.7</span> Improving the thread-safety of the object system </h3>
<div class="outline-text-3" id="text-1.7">

<p>Developers continually attempt to reduce SBCL's reliance on a single
"world" lock.  This effort has lead to the elimination of some
re-entrancy issues, and to the introduction of a few concurrency bugs,
many of them related to the Common Lisp Object System (CLOS).  Some
bugs are easily triggered, other depend on rare race conditions.  Some
could be fixed with additional lockings, others through the use of
mostly non-blocking synchronisation techniques, and others still by
outright modifying the behaviour of the object system.  This project
requires the student to organise known or potential concurrency bugs
in PCL, SBCL's implementation of CLOS, and attempt to fix them.
</p>

</div>

<div id="outline-container-1.7.1" class="outline-4">
<h4 id="sec-1.7.1"><span class="section-number-4">1.7.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.7.1">

<ol>
<li>
Collect, organise, and diagnose concurrency bugs in PCL;
</li>
<li>
Fix some of these bugs;
</li>
<li>
Develop a methodology to trigger hard-to-detect concurrency bugs in
PCL;
</li>
<li>
Suggest generally-applicable techniques to eliminate such bugs from
PCL and the runtime system (optional).

</li>
</ol>
</div>

</div>

<div id="outline-container-1.7.2" class="outline-4">
<h4 id="sec-1.7.2"><span class="section-number-4">1.7.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.7.2">

<p>Basic understanding of shared-memory concurrency.  A conservative
understanding of specific memory models will be developed in parallel
with the work.
</p>
</div>

</div>

<div id="outline-container-1.7.3" class="outline-4">
<h4 id="sec-1.7.3"><span class="section-number-4">1.7.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.7.3">

<p>The student will encounter concurrency bugs in a complex stateful
system that exploits both lock-based concurrency control and lock-free
operations.  They will develop an understanding for the issues
encountered in such systems, and learn how to detect and then solve
them.
</p>
</div>
</div>

</div>

<div id="outline-container-1.8" class="outline-3">
<h3 id="sec-1.8"><span class="section-number-3">1.8</span> Threading/locking debugging facilities </h3>
<div class="outline-text-3" id="text-1.8">

<p>SBCL exposes low-level shared memory concurrency and parallelism
constructs: threads, locks, atomic operations, etc.  Such constructs
are easily misused, and other projects and languages implementations
have developed tools to detect and understand concurrency bugs (both
in terms of correctness and of performance).  For example, Linux's
locking correctness validator (lockdep) seems well suited to Common
Lisp.  Other proven tools would no doubt benefit to SBCL and its
users.  A successful project would identify existing (or create) tools
that are promising to assist in the development of threaded
applications with SBCL, and implement and document some of these
tools.
</p>

</div>

<div id="outline-container-1.8.1" class="outline-4">
<h4 id="sec-1.8.1"><span class="section-number-4">1.8.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-1.8.1">

<ol>
<li>
Survey of proven threading/locking debugging tools;
</li>
<li>
Implementation and integration of at least one such tool in SBCL;
</li>
<li>
Documentation for these extensions;
</li>
<li>
(optional) Suggestion of alternative less error-prone constructs
for sb-concurrency or sb-thread.

</li>
</ol>
</div>

</div>

<div id="outline-container-1.8.2" class="outline-4">
<h4 id="sec-1.8.2"><span class="section-number-4">1.8.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-1.8.2">

<p>Familiarity with the POSIX threads programming model.  An awareness of
the execution process for multi-socket systems with multiple levels of
cache would be useful, but not necessary.
</p>
</div>

</div>

<div id="outline-container-1.8.3" class="outline-4">
<h4 id="sec-1.8.3"><span class="section-number-4">1.8.3</span> Student learning </h4>
<div class="outline-text-4" id="text-1.8.3">

<p>The student would become intimately familiar with the sort of bugs
commonly encountered in threaded system.  They would also study state
of the art tools to detect such bugs, and replicate some of them for
integration in a pre-existing environment.  They would also exercise
their technical writing skills to document the tools and describe
their correct use.  Finally, they would demonstrate the ability to
propose elegant architectural solutions to complex issues.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> High-level optimisation </h2>
<div class="outline-text-2" id="text-2">

<p>These project are mostly concerned with extending the initial
(mostly target-independent) optimisation phase.
</p>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> Efficient integer truncate/floor/ceiling by constants </h3>
<div class="outline-text-3" id="text-2.1">

<p>Integer division is notorious for being slow.  However, it is also
known that the divisor is constant in the vast majority of cases, and
serious compilers exploit that fact to simplify divisions into
sequences of simpler multiplications, shifts, and additions.  SBCL
implements such a simplification only for truncated division of
unsigned machine words.  Floor and ceiling are less commonly supported
natively in programming languages, and there is a dearth of literature
describing how to simplify them.  However, it is possible to do so,
for both signed and unsigned machine integers.  It is also possible to
specialise the routines for tagged arithmetic.  A complete execution
of this project would include the development of simplification
routines for signed and unsigned truncate, floor and ceiling divisions
by integer constants.  Some of the simplifications, particularly those
concerning tagged integers, will be widely applicable and likely
novel.
</p>

</div>

<div id="outline-container-2.1.1" class="outline-4">
<h4 id="sec-2.1.1"><span class="section-number-4">2.1.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-2.1.1">

<ol>
<li>
Implement strength reduction of signed truncated division;
</li>
<li>
Determine how to correctly simplify floor and ceiling division;
</li>
<li>
Implement strength reduction of floor and ceiling division;
</li>
<li>
Adapt the algorithms to take tagging into account;
</li>
<li>
Extend the test suite for integer division by constants;
</li>
<li>
(optional) Extend the work to constant division by rationals.

</li>
</ol>
</div>

</div>

<div id="outline-container-2.1.2" class="outline-4">
<h4 id="sec-2.1.2"><span class="section-number-4">2.1.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-2.1.2">

<p>Basic number theory. Some work will likely be at the assembly level,
but what little is necessary can be acquired on the fly.
</p>
</div>

</div>

<div id="outline-container-2.1.3" class="outline-4">
<h4 id="sec-2.1.3"><span class="section-number-4">2.1.3</span> Student learning </h4>
<div class="outline-text-4" id="text-2.1.3">

<p>The student would apply pure mathematics concepts from number theory
to understand how to correctly simplify operations in computer
programs.  They would likely become acquainted with the performance
characteristics of contemporary computers to decide how to let number
theory guide the simplification of divisions by integers.  They would
also show the correctness of simple but novel variations, and exploit
their understanding of the problem domain to develop tests that are
likely to detect incorrect transformations.
</p>
</div>
</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> Exploiting switch/case in standard control structures </h3>
<div class="outline-text-3" id="text-2.2">

<p>While Common Lisp exposes case constructs, there is no standard
support for constant-time computed goto or C-style switch/case flow
control.  A partial patch to extend SBCL with such an
indirect-jump-based control construct exists.  First, it must be
completed and tested, and, second, the new construct should be
exploited in a standard-compliant manner in the implementation of
standard flow control macros.  This project would greatly improve the
performance of some state machines implementations, and benefit to a
wide range of programs that use standard case constructs directly.
</p>

</div>

<div id="outline-container-2.2.1" class="outline-4">
<h4 id="sec-2.2.1"><span class="section-number-4">2.2.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-2.2.1">

<ol>
<li>
Forward-port the indirect-jump patch;
</li>
<li>
Expose the new operator in a standard-compliant manner;
</li>
<li>
Create benchmarks to understand how to best use this new operator;
</li>
<li>
Exploit the operator in the implementation of standard flow control
macros;
</li>
<li>
(optional) For the patch to additional computer architectures.

</li>
</ol>
</div>

</div>

<div id="outline-container-2.2.2" class="outline-4">
<h4 id="sec-2.2.2"><span class="section-number-4">2.2.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-2.2.2">

<p>Knowledge of x86[-64] assembly language. Familiarity with advanced
compilation techniques is an advantage.
</p>
</div>

</div>

<div id="outline-container-2.2.3" class="outline-4">
<h4 id="sec-2.2.3"><span class="section-number-4">2.2.3</span> Student learning </h4>
<div class="outline-text-4" id="text-2.2.3">

<p>The student would gain an overview of the complete pipeline in a
production compiler, from the front-end, to dataflow analyses, to the
generation of machine code.  They would also have to work within an
ISO standard to expose a new feature to users.  Finally, they would
improve their understanding of the low-level performance of modern
architectures, particularly at the level of branch prediction, in
order to transparently improve the runtime efficiency of flow control
constructs.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Middle end infrastructure </h2>
<div class="outline-text-2" id="text-3">

<p>These projects are concerned with the target-independent optimisation
phase as well, but modifies its infrastructure, rather than using it
to add more smartness to the compiler.
</p>

</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> Accurate and correct numeric type derivation </h3>
<div class="outline-text-3" id="text-3.1">

<p>The static derivation of intervals for the values taken by
mathematical operations is essential for Common Lisp compilers to
convert idiomatic programs to machine code comparable with that of
less safe languages.  SBCL's implementation is fairly complicated, and
seems subtly incorrect for floating-point types, particularly when the
rounding mode differs between the compilation and execution
environments.  Upon completion, this project would result in simpler
and more robust routines to propagate numeric intervals for SBCL.
</p>

</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1"><span class="section-number-4">3.1.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-3.1.1">

<ol>
<li>
A na√Øve but clearly correct interval derivation module;
</li>
<li>
Development of test cases to trigger issues in numeric
(floating-point) type derivation;
</li>
<li>
More sophisticated interval derivations;
</li>
<li>
(optional) Express the interval derivation logic in portable Common
Lisp for the cross-compiler.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2"><span class="section-number-4">3.1.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-3.1.2">

<p>Some real analysis. Minimal familiarity with numerical analysis and
with the implementation of floating-point arithmetic in computers.
</p>
</div>

</div>

<div id="outline-container-3.1.3" class="outline-4">
<h4 id="sec-3.1.3"><span class="section-number-4">3.1.3</span> Student learning </h4>
<div class="outline-text-4" id="text-3.1.3">

<p>The student will bridge between their understanding of mathematical
operations with their concrete approximation in contemporary computers
to safely characterise the behaviour of arbitrary Common Lisp
expressions.  They will thus acquire experience with simple numerical
analysis, and become acquainted with the difference between
theoretical mathematics and floating-point operations.  They will also
learn to exploit the concrete representation of floating-point values
to implement simple and efficient, but correct numerical algorithms.
</p></div>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> Expression optimisation </h3>
<div class="outline-text-3" id="text-3.2">

<p>Although SBCL performs fairly sophisticated analyses, subsequent
transformations are performed (except for a few exception) bottom-up,
one function call at a time.  A large body of classic techniques is
available to optimise complete (side-effect-free) expression trees
top-down.  Upon completion, this project would extend SBCL with a
system to define tree rewriting rules, and execute them on code.
Arithmetic and bitwise operations would likely benefit, as would
modular arithmetic and embedded domain-specific languages.
</p>

</div>

<div id="outline-container-3.2.1" class="outline-4">
<h4 id="sec-3.2.1"><span class="section-number-4">3.2.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-3.2.1">

<ol>
<li>
Detection and visualisation of expression trees in the first
intermediate representation (IR1);
</li>
<li>
Insertion of a top-down rewriting pass in the IR1 optimisation
loop;
</li>
<li>
Development of a pattern and transform definition language for
expression trees;
</li>
<li>
Implementation of a few rewrites with this new infrastructure.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.2.2" class="outline-4">
<h4 id="sec-3.2.2"><span class="section-number-4">3.2.2</span> Prerequisite </h4>
<div class="outline-text-4" id="text-3.2.2">

<p>Basic discrete mathematics.  Familiarity with formal grammars and
automata theory is optional.
</p>
</div>

</div>

<div id="outline-container-3.2.3" class="outline-4">
<h4 id="sec-3.2.3"><span class="section-number-4">3.2.3</span> Student learning </h4>
<div class="outline-text-4" id="text-3.2.3">

<p>The student would improve their understanding of the compilation
process for pure expressions, and review, then implement, classic
techniques for their improvement.  They would also develop a new
internal library feature, and exploit it to show concrete improvements
in the compiler's output.
</p>
</div>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3"><span class="section-number-3">3.3</span> Coarser type derivation system </h3>
<div class="outline-text-3" id="text-3.3">

<p>Common Lisp's type system is extremely expressive, and it is expected
that complicated types will lead to slow type tests and comparisons.
SBCL exploits this expressiveness to implement fine-grained
flow-sensitive analyses.  In many cases, particularly when execution
speed is a secondary concern, tracking types less precisely would
improve compilation speed significantly, without overly affecting the
object code.  This project consists of first identifying points in
SBCL's analysis passes where types could be profitably widened, of
designing a coarse type lattice that accelerates compilation, and of
implementing that coarse lattice in SBCL.
</p>

</div>

<div id="outline-container-3.3.1" class="outline-4">
<h4 id="sec-3.3.1"><span class="section-number-4">3.3.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-3.3.1">

<ol>
<li>
Gather example code that exercises SBCL's type-based analyses;
</li>
<li>
Determine what operations exhibit complexity blowups in these
examples;
</li>
<li>
Define a simple type widening operator, and insert it in key
places;
</li>
<li>
Experiment with various widening strategies and alternative type
lattices to improve compilation speed while preserving correctness
and reasonable execution efficiency.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.3.2" class="outline-4">
<h4 id="sec-3.3.2"><span class="section-number-4">3.3.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-3.3.2">

<p>Proficiency in discrete mathematics, particularly set theory.  The
student is expected to become familiar with data flow analyses in the
course of the project.
</p>
</div>

</div>

<div id="outline-container-3.3.3" class="outline-4">
<h4 id="sec-3.3.3"><span class="section-number-4">3.3.3</span> Student learning </h4>
<div class="outline-text-4" id="text-3.3.3">

<p>The student will acquire experience at profiling a complex symbolic
manipulation system. They will then apply their results to improve the
practical performance of the system, while preserving its mathematical
correctness.  They will also strengthen their mastery of the static
(data flow) analysis of impure languages.
</p>
</div>
</div>

</div>

<div id="outline-container-3.4" class="outline-3">
<h3 id="sec-3.4"><span class="section-number-3">3.4</span> Quick compilation </h3>
<div class="outline-text-3" id="text-3.4">

<p>SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
straightforward compilation, an intermediate choice between the
current extremes of a full type-propagating compiler and an
s-expression interpreter.  If completed, this project would enable
time-consuming phases of the compiler to be disabled or replaced with
coarser, but more quickly-executed, ones.  This would result in
reduced compilation times for code that isn't performance-critical,
and, potentially, the ability to compile very large computer-generated
functions.
</p>

</div>

<div id="outline-container-3.4.1" class="outline-4">
<h4 id="sec-3.4.1"><span class="section-number-4">3.4.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-3.4.1">

<ol>
<li>
Identify the most time-consuming phases of the compiler;
</li>
<li>
Extend performance and correctness tests for the compiler;
</li>
<li>
Determine how to disable or simplify time-consuming phases, while
preserving correctness;
</li>
<li>
(optional) Develop alternatives for a few recursive or super-linear
computations in the compilation process.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.4.2" class="outline-4">
<h4 id="sec-3.4.2"><span class="section-number-4">3.4.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-3.4.2">

<p>No strict prerequisite. An interest in compilation would be helpful,
as would familiarity with the analysis and design of algorithms and
data structures.  The student will become comfortable with set and
lattice theory.
</p>
</div>

</div>

<div id="outline-container-3.4.3" class="outline-4">
<h4 id="sec-3.4.3"><span class="section-number-4">3.4.3</span> Student learning </h4>
<div class="outline-text-4" id="text-3.4.3">

<p>The student will gather representative code samples from actual users,
and exploit them to build an understanding of the empiric performance
of SBCL's compiler.  They will also use this data to develop
benchmarks that reflect real-world needs, and design tests to convince
themselves and others that changes to a large system preserve its
correctness.  They will finally exploit these tools to determine which
parts of the compiler should be disabled or simplified, and how to do
so.
</p>
</div>
</div>

</div>

<div id="outline-container-3.5" class="outline-3">
<h3 id="sec-3.5"><span class="section-number-3">3.5</span> Precise type derivation </h3>
<div class="outline-text-3" id="text-3.5">

<p>SBCL and CMUCL are recognized for the strength of their type-directed
optimisations, which depends on the quality of the type propagation
pass.  That pass exhibits severe weaknesses in the presence of
recursion or of assignments: such non-trivial bindings are initialised
with a static type of T (barring any user-provided declaration), and
that type is iteratively tightened.  This approach has the advantage
of always assigning correct types at any time, even if a fixpoint is
not yet reached.  However, when compilation times are not an issue and
the analysis is executed until termination, initialising bindings with
a static time of NIL (the bottom type) and widening the type
assignments iteratively would result in the automatic derivation of
more precise types.  If completed, this project would implement such a
precise flow-sensitive data-flow analysis, and let it be enabled on
demand within the normal compilation pipeline.
</p>

</div>

<div id="outline-container-3.5.1" class="outline-4">
<h4 id="sec-3.5.1"><span class="section-number-4">3.5.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-3.5.1">

<ol>
<li>
Code samples exhibiting disastrously weak type derivation;
</li>
<li>
A correct and probably very slow (or even non-terminating)
implementation of a precise type derivation pass;
</li>
<li>
Integration of that pass in the compilation pipeline;
</li>
<li>
(optional) Experiments with strategies to ensure the pass
terminates after reasonable computation times.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.5.2" class="outline-4">
<h4 id="sec-3.5.2"><span class="section-number-4">3.5.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-3.5.2">

<p>Proficiency in discrete mathematics, particularly set theory.  The
student is expected to become familiar with data flow analyses in the
course of the project.
</p>
</div>

</div>

<div id="outline-container-3.5.3" class="outline-4">
<h4 id="sec-3.5.3"><span class="section-number-4">3.5.3</span> Student learning </h4>
<div class="outline-text-4" id="text-3.5.3">

<p>The student will learn to apply abstract concepts in the design of a
data flow analysis pass for an impure language.  They will do so
within the limits of a standards-defined language that is not
explicitly designed to enable sophisticated static analyses.  Finally,
they will research and discover strategies to render practically
usable a theoretically correct symbolic process.
</p>




</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Back end work </h2>
<div class="outline-text-2" id="text-4">

<p>The following projects improve or add functionality in the back end of
the compiler, the phase that exploits architecture-specific
information to generate machine code.
</p>

</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1"><span class="section-number-3">4.1</span> Modernising a graph-colouring register allocator </h3>
<div class="outline-text-3" id="text-4.1">

<p>Variables are mapped to registers or stack locations in SBCL with a
straightforward graph-colouring allocator.  Graph colouring is a
well-known combinatorial optimisation problem, and, although it is
NP-Hard, some heuristic methods are known to perform very well in
practice.  Exploiting such methods in the register allocator would
enable code to avoid spills when register pressure is high; this is a
particularly pressing issue on x86.  Moreover, while SBCL's register
allocator allocates registers (or stack slots) to variables,
contemporary allocator obtain much better results by mapping registers
to values, thus allowing the values associated with a single variable
to be stored in different locations at distinct points in the code.
This can be achieved to a lesser extent by more closely tracking
values within a single basic block and by splitting live ranges in
multiple sections, if compensation code is inserted as needed.
Through any of these means, the project would improve the performance
of code that exhibits high register pressure.
</p>

</div>

<div id="outline-container-4.1.1" class="outline-4">
<h4 id="sec-4.1.1"><span class="section-number-4">4.1.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-4.1.1">

<ol>
<li>
Accumulate a few functions that exhibit register allocation issues;
</li>
<li>
Improve the graph-colouring heuristic by adapting well-known
methods;
</li>
<li>
Allocate registers more finely within a single basic block;
</li>
<li>
(optional) Implement a live-range splitting pass;
</li>
<li>
(optional) Exploit register-register exchange instructions to
enable SSA-style register allocation.

</li>
</ol>
</div>

</div>

<div id="outline-container-4.1.2" class="outline-4">
<h4 id="sec-4.1.2"><span class="section-number-4">4.1.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-4.1.2">

<p>Basic familiarity with assembly language. Some knowledge of discrete
mathematics and of graph theory.
</p>
</div>

</div>

<div id="outline-container-4.1.3" class="outline-4">
<h4 id="sec-4.1.3"><span class="section-number-4">4.1.3</span> Student learning </h4>
<div class="outline-text-4" id="text-4.1.3">

<p>The student will apply sophisticated heuristics to solve an NP-Hard
problem.  They will also learn to map abstract discrete optimisation
concepts to concrete low-level concepts such as architectural
registers and assembly instructions, and develop specialised methods
that straddle the two views to exploit domain-specific knowledge.
</p>
</div>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2"><span class="section-number-3">4.2</span> Selecting concrete representations cleverly </h3>
<div class="outline-text-3" id="text-4.2">

<p>An essential trick to SBCL's performance is its ability to represent
the same data in multiple manners, as boxed values, or as
machine-native values, e.g. signed or unsigned words, or floating
point values in registers.  However, not all operations have the same
requirements: some, like arbitrary calls, are better served with boxed
values, while others, like floating-point arithmetic, are more
efficient on natively-represented values.  SBCL currently assigns a
single concrete representation for each variable.  This selection
algorithm can be revisited and improved, but the constraints under
which it operates could be relaxed as well: nothing prevents a
variable's values to be represented in different manners at distinct
program points, as long as conversion code is inserted at key
locations.  In particular, this additional leeway imposes a very low
overhead if it is only exploited within each basic block.  This
project requires creativity to understand an exotic combinatorial
optimisation problem and determine how best to tackle it and adapt
existing methods; if successful, it would likely result in the
development of a novel algorithm for a problem essential to the
performance of dynamically-typed languages, and its application in a
pre-existing compiler, thus showing clear practical improvement.
</p>

</div>

<div id="outline-container-4.2.1" class="outline-4">
<h4 id="sec-4.2.1"><span class="section-number-4">4.2.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-4.2.1">

<ol>
<li>
Describe the objective and constraints in the representation
selection problem;
</li>
<li>
Reduce the representation selection problem to better understood
optimisation problems with efficient heuristics;
</li>
<li>
Improve the currently-existing representation selection heuristic;
</li>
<li>
(optional) Implement value-based representation selection within
basic blocks;
</li>
<li>
(optional) Implement SSA-style representation selection, with
conversion code at control flow fork/join points.

</li>
</ol>
</div>

</div>

<div id="outline-container-4.2.2" class="outline-4">
<h4 id="sec-4.2.2"><span class="section-number-4">4.2.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-4.2.2">

<p>Basic familiarity with assembly language. Some knowledge of discrete
mathematics and of graph theory.
</p>
</div>

</div>

<div id="outline-container-4.2.3" class="outline-4">
<h4 id="sec-4.2.3"><span class="section-number-4">4.2.3</span> Student learning </h4>
<div class="outline-text-4" id="text-4.2.3">

<p>The student will learn to describe a complicated, industrial,
combinatorial optimisation problem formally, and to reduce it to
classic optimisation problems.  They will then have an opportunity to
exploit this theoretical basis to improve on an existing heuristic, in
practice.  Finally, they will be lead to iteratively improve that
formal model to better represent the actual problem, while ensuring
the existence of efficient solving methods.
</p>
</div>
</div>

</div>

<div id="outline-container-4.3" class="outline-3">
<h3 id="sec-4.3"><span class="section-number-3">4.3</span> Peephole optimisation </h3>
<div class="outline-text-3" id="text-4.3">

<p>Most of the cleverness in SBCL is in the front-end.  Once Common Lisp
has been lowered to an explicitly-typed C-level intermediate
representation, very few analyses and optimisations are performed,
when compared to other compilers.  As a result, clearly suboptimal
code sequences are generated, particularly at the boundary between two
operations.  A peephole optimisation pass would detect such sequences
and eliminate them or replace them with more efficient code.  This
could be achieved by considering sequences of instructions or of
virtual operations (instruction templates), or even by reconstructing
a tree from virtual operations.  The project would implement such a
peephole pass, offer a modular way to define new patterns, and add a
few such patterns for commonly-used architectures.
</p>

</div>

<div id="outline-container-4.3.1" class="outline-4">
<h4 id="sec-4.3.1"><span class="section-number-4">4.3.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-4.3.1">

<ol>
<li>
Determine how to inject ad hoc rewrites during the emission of
machine code;
</li>
<li>
Implement a simple, specialised, optimisation using that mechanism;
</li>
<li>
Develop a pattern-definition language appropriate for the chosen
rewriting mechanism;
</li>
<li>
Implement some rewrites using that pattern-definition language, and
show improvements in some degenerate cases.

</li>
</ol>
</div>

</div>

<div id="outline-container-4.3.2" class="outline-4">
<h4 id="sec-4.3.2"><span class="section-number-4">4.3.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-4.3.2">

<p>Familiarity with assembly language in at least one platform supported
by SBCL.
</p>
</div>

</div>

<div id="outline-container-4.3.3" class="outline-4">
<h4 id="sec-4.3.3"><span class="section-number-4">4.3.3</span> Student learning </h4>
<div class="outline-text-4" id="text-4.3.3">

<p>The student will have evaluated how to best extend a system in a
direction that was not considered during its initial design.  They
will also review various approaches to improve code generation at a
low level, and create a new domain-specific language that will be used
by others.  They will finally develop code to detect and improve code
at the assembly level.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Diving in the runtime system </h2>
<div class="outline-text-2" id="text-5">

<p>Projects in this section really let the coder feel bits and syscalls
between their toes.  Work involving the runtime system tends to be
challenging because the programmer must take into account many facets
of SBCL, from library code, to type information in the middle end, to
invariants in the back end.  These are high risk/high reward projects;
most of the risk is due to a high potential for failure, but it's also
not obvious that a successful implementation will result in any
improvement.
</p>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1"><span class="section-number-3">5.1</span> Simpler structure layout </h3>
<div class="outline-text-3" id="text-5.1">

<p>Structure objects in Common Lisp support single inheritance and typed
slots so as to offer both extensibility and performance.  SBCL
implements slots of unboxed data by allocating them from the end of
(variable-length, because of inheritance) structure objects.  Access
to an unboxed slot thus first determines the size of the current
object in all but a few cases.  However, nothing prevents boxed and
unboxed slots from being interleaved, as long as alignment
requirements are respected and the garbage collector's scanning
routine for structures is suitably adapted.  A branch partially
implements this improvement, and the work is assuredly feasible.  If
completed, this project would lead to more efficient access to
structure slots, and potentially let structures be laid out compatibly
with some ABIs, thus simplifying foreign calls.
</p>

</div>

<div id="outline-container-5.1.1" class="outline-4">
<h4 id="sec-5.1.1"><span class="section-number-4">5.1.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.1.1">

<ol>
<li>
Forward port the interleaved unboxed slot branch;
</li>
<li>
Develop tests for the garbage collector, the interpreter, and the
introspection facilities;
</li>
<li>
Determine how to use this new freedom in object layouts;
</li>
<li>
Measure the impact of the changes on the memory usage and on the
runtime performance of representative programs.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.1.2" class="outline-4">
<h4 id="sec-5.1.2"><span class="section-number-4">5.1.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.1.2">

<p>Some experience with Common Lisp. Familiarity with x86 or x86-64
assembly language is helpful but optional.
</p>
</div>

</div>

<div id="outline-container-5.1.3" class="outline-4">
<h4 id="sec-5.1.3"><span class="section-number-4">5.1.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.1.3">

<p>The student would become comfortable with data representation issues
at a low level, develop and execute tests for a fundamental part of
the system, and guide technical decisions with empiric measures from
benchmarks that reflect reality.  Moreover, this would be done within
the constraints specified by a standard.
</p>
</div>
</div>

</div>

<div id="outline-container-5.2" class="outline-3">
<h3 id="sec-5.2"><span class="section-number-3">5.2</span> Software write barriers </h3>
<div class="outline-text-3" id="text-5.2">

<p>Generational garbage collectors attempt to process the heap
incrementally by determining when writes to old objects may have
created new references.  SBCL implements such write barriers with
hardware memory protection.  This means that writes can only be
tracked at a coarse granularity (a page, at best), and that handling
writes to previously clean pages is a complex affair involving several
round trips between userspace and the operating system.  Another
approach is to modify the code generated by the compiler to explicit
write barrier instruction sequences; each approach offers different
performance characteristics, and it is not yet clear which is
preferable for SBCL.  Previous attempts at implementing card marking
write barriers showed interesting results, but still exhibit subtle
bugs.  If successful, this project would forward port one such
attempt, develop tests for the software write barriers, and implement
an architectural change that involves large portions of the code base.
</p>

</div>

<div id="outline-container-5.2.1" class="outline-4">
<h4 id="sec-5.2.1"><span class="section-number-4">5.2.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.2.1">

<ol>
<li>
Forward port of a software write barrier branch;
</li>
<li>
Development of unit tests for the garbage collector, particularly
for the write barriers;
</li>
<li>
Characterisation of the strengths and weaknesses of software and
memory protection write barriers;
</li>
<li>
(optional) Determine how best to use software write barriers in
SBCL, e.g. by allowing boxed and unboxed objects to be allocated
contiguously, or by enabling huge pages.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.2.2" class="outline-4">
<h4 id="sec-5.2.2"><span class="section-number-4">5.2.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.2.2">

<p>Familiarity with x86-64 assembly language.  
</p>
</div>

</div>

<div id="outline-container-5.2.3" class="outline-4">
<h4 id="sec-5.2.3"><span class="section-number-4">5.2.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.2.3">

<p>The student would acquire experience working with compilers and
runtime systems at the assembly level, and develop techniques to
automatically detect subtle code generation and concurrency bugs.
They would also improve their ability to characterise the performance
of (a part of) a complex system, and act upon that information to
improve such a system.
</p>
</div>
</div>

</div>

<div id="outline-container-5.3" class="outline-3">
<h3 id="sec-5.3"><span class="section-number-3">5.3</span> Improving SBCL's memory allocator </h3>
<div class="outline-text-3" id="text-5.3">

<p>SBCL's memory management system includes a page-level block allocator.
It is mainly used to manage large objects and thread-local allocation
regions.  The scheme exhibits at least two clear deficiencies. First,
large objects are always allocated on page boundaries, exacerbating
cache aliasing issues, in addition to, in effect, misaligning the
contents of vectors.  Second, normal (pointer-ful) and unboxed
(pointer-free) blocks are interleaved, but regular pages tend to be
write-protected and unboxed pages never are; these short ranges of
addresses with different properties increase the address space
management overhead for the operating system, which is reflected in
long times spent in system code.  There are likely other problems that
can be improved with little effort; for example, the proportion of
zeros in image files hints at a fragmentation issue.
</p>
<p>
Upon completion, this project would have lead to the identification of
systems-level issues in SBCL's memory management strategies, and to
the application of changes to eliminate or alleviate these issues.
</p>

</div>

<div id="outline-container-5.3.1" class="outline-4">
<h4 id="sec-5.3.1"><span class="section-number-4">5.3.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.3.1">

<ol>
<li>
Microbenchmarks to understand the effect of aliasing and data
misalignment when processing large (vector) data;
</li>
<li>
Development of alternative large object allocation and deallocation
routines that improve the cache utilisation of SBCL;
</li>
<li>
Development of a block allocation strategy that is better suited to
the algorithms and data structures operating systems use to manage
ranges of virtual memory;
</li>
<li>
(optional) Identification of further global issues in SBCL's memory
management.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.3.2" class="outline-4">
<h4 id="sec-5.3.2"><span class="section-number-4">5.3.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.3.2">

<p>Proficiency in C.  Basic understanding of computer architecture and of
contemporary operating systems.
</p>
</div>

</div>

<div id="outline-container-5.3.3" class="outline-4">
<h4 id="sec-5.3.3"><span class="section-number-4">5.3.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.3.3">

<p>The student will gain concrete experience at debugging and tuning the
performance of a complete system, with interactions between a managed
language runtime, the operating system, and the CPU's
microarchitecture.  In addition to applying concepts from computer
architecture and operating systems theory to improve the performance
of a runtime system, they will also apply statistical techniques to
convincingly exhibit these improvements.
</p>
</div>
</div>

</div>

<div id="outline-container-5.4" class="outline-3">
<h3 id="sec-5.4"><span class="section-number-3">5.4</span> Garbage collection debugging and heap assertions </h3>
<div class="outline-text-3" id="text-5.4">

<p>Pointer-based data structures can be particularly difficult to debug;
automatic garbage collection eliminates some of these bugs, but also
introduces subtle memory leaks.  Some ad hoc tools are already
available to explore SBCL's heap semi-automatically and thus track
down spurious roots.  They are not user-friendly, and the information
could be exposed more efficiently.  Similarly, SBCL exposes tools to
fully traverse the heap; however, the functions are brittle and
primitive, and it is difficult to verify that some heap-allocated data
structure satisfy its invariants, particularly if the structure is
large.  This project consists of improving upon existing tools to
allow programmers to efficiently detect and eliminate memory leaks and
check problem-specific data structure invariants.
</p>

</div>

<div id="outline-container-5.4.1" class="outline-4">
<h4 id="sec-5.4.1"><span class="section-number-4">5.4.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.4.1">

<ol>
<li>
Development of a few fixed assertions (e.g. that an objects is
dead, or is refered by exactly one heap object) that can be checked
asynchronously, during or after major garbage collection cycles;
</li>
<li>
A vistualisation tool to help track references in object graphs,
and to better understand the size of data in SBCL's heap;
</li>
<li>
Integration of the assertions in minor GC;
</li>
<li>
(optional) Development of a domain specific language to allow the
description of specialised assertions.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.4.2" class="outline-4">
<h4 id="sec-5.4.2"><span class="section-number-4">5.4.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.4.2">

<p>Familiarity with manual memory management, and with the manipulation
of pointers.  Knowledge of graph theory and predicate logic may be
useful.  Interest in the low end of complexity classes would be an
asset.
</p>
</div>

</div>

<div id="outline-container-5.4.3" class="outline-4">
<h4 id="sec-5.4.3"><span class="section-number-4">5.4.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.4.3">

<p>The student would identify how to respond to the needs expressed by
programmers, most likely by taking inspiration from tools described in
scientific literature.  They would also become proficient at
processing large data sets (heaps) with streaming approaches that use
little auxiliary storage.  Finally, they would gain experience in the
design and implementation of domain specific languages: the language
will balance the conflicting goals of expressiveness and of efficient
execution within very little writable storage.
</p>
</div>
</div>

</div>

<div id="outline-container-5.5" class="outline-3">
<h3 id="sec-5.5"><span class="section-number-3">5.5</span> A hybrid copying/mark-and-sweep garbage collector </h3>
<div class="outline-text-3" id="text-5.5">

<p>SBCL's garbage collector is a mostly-copying generational garbage
collector (gencgc).  Heap sizes have grown by multiple orders of
magnitude since the era when gencgc was designed.  It now seems
interesting to only use a copying garbage collector for
newly-allocated data, and to reduce writes to older data by performing
major collections with a mark-and-sweep pass.  Depending on the
student's affinity, this may prove to be less work or more interesting
than integrating a third-party design.  Completion of this project
entails the development of a memory management subsystem, including
difficult software development choices.  The result would be
improvements in the responsiveness and throughput of a production
language implementation.
</p>

</div>

<div id="outline-container-5.5.1" class="outline-4">
<h4 id="sec-5.5.1"><span class="section-number-4">5.5.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.5.1">

<ol>
<li>
Description of the interface between SBCL's runtime and its memory
management subsystem;
</li>
<li>
Implementation of mark-and-sweep in a distinct heap from the
current copying one, with eviction from the copying heap to the
mark-and-sweep heap;
</li>
<li>
Integration of the mark-and-sweep heap with the copying heap and
its data structures;
</li>
<li>
(optional) Adaptation of mark-and-sweep GC to efficiently load
images and to save less fragmented images;
</li>
<li>
(optional) Improved performance on read-mostly data.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.5.2" class="outline-4">
<h4 id="sec-5.5.2"><span class="section-number-4">5.5.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.5.2">

<p>Knowledge of C and understanding of operating systems internals. 
</p>
</div>

</div>

<div id="outline-container-5.5.3" class="outline-4">
<h4 id="sec-5.5.3"><span class="section-number-4">5.5.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.5.3">

<p>The student will appreciate the challenges faced by the
implementations of languages with managed memory.  They will
understand the theory of classic garbage collection and memory
management algorithms, and implement them.  They will also develop
code that interacts directly with the operating system in order to
manage resources efficiently.
</p>
</div>
</div>

</div>

<div id="outline-container-5.6" class="outline-3">
<h3 id="sec-5.6"><span class="section-number-3">5.6</span> Replacing the garbage collector with MPS </h3>
<div class="outline-text-3" id="text-5.6">

<p>SBCL's garbage collector is well-modularised, but shares code only
with CMUCL, and suffers from a rigid design.  Ravenbrook's Memory Pool
System (MPS) is a flexible, high-performance, open source memory
management subsystem, and SBCL would likely gain in performance and in
robustnessby replacing its specialised garbage collector with MPS,
augmented with SBCL-specific extensions.  If successful, this project
would deeply integrate a complex library in a large system by
characterising their respective requirements and judiciously inserting
logic to make the two designs compatible.
</p>

</div>

<div id="outline-container-5.6.1" class="outline-4">
<h4 id="sec-5.6.1"><span class="section-number-4">5.6.1</span> Deliverables </h4>
<div class="outline-text-4" id="text-5.6.1">

<ol>
<li>
Description of the interface between SBCL's runtime and its memory
management subsystem;
</li>
<li>
Stand-alone program that interfaces with MPS and presents
challenges similar to that of SBCL (tagged pointers, several types
of weaknesses, some data layout described by normal heap objects,
ability to load a heap from disk, etc.);
</li>
<li>
Port the stand-alone program's design to SBCL, for a single
platform;
</li>
<li>
(optional) Determine which pools are better suited to Common Lisp,
and how to expose that choice to users.
</li>
<li>
(optional) Port SBCL/MPS to several platforms.

</li>
</ol>
</div>

</div>

<div id="outline-container-5.6.2" class="outline-4">
<h4 id="sec-5.6.2"><span class="section-number-4">5.6.2</span> Prerequisites </h4>
<div class="outline-text-4" id="text-5.6.2">

<p>Knowledge of C and understanding of operating systems internals.
</p>
</div>

</div>

<div id="outline-container-5.6.3" class="outline-4">
<h4 id="sec-5.6.3"><span class="section-number-4">5.6.3</span> Student learning </h4>
<div class="outline-text-4" id="text-5.6.3">

<p>The student will become familiar with the memory management subsystem
used in a managed language that supports OS threads, and with the
internals of a state of the art garbage collector.  They will then
gain experience with the integration of independently-developed
systems.  They will also interface directly with the operating systems
as required for the development of a performance-oriented runtime
system.
</p>

</div>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Projects that may be further described if there is interest </h2>
<div class="outline-text-2" id="text-6">

<p>The path for these project is significantly murkier, as is their
usefulness.
</p>

</div>

<div id="outline-container-6.1" class="outline-3">
<h3 id="sec-6.1"><span class="section-number-3">6.1</span> Free-er form displaced arrays </h3>
<div class="outline-text-3" id="text-6.1">

</div>

</div>

<div id="outline-container-6.2" class="outline-3">
<h3 id="sec-6.2"><span class="section-number-3">6.2</span> Autodxification of higher-order functions </h3>
<div class="outline-text-3" id="text-6.2">

</div>

</div>

<div id="outline-container-6.3" class="outline-3">
<h3 id="sec-6.3"><span class="section-number-3">6.3</span> Better failure modes for heap overflow </h3>
<div class="outline-text-3" id="text-6.3">

<p>Flexible heap, and GC before allocating.
</p></div>

</div>

<div id="outline-container-6.4" class="outline-3">
<h3 id="sec-6.4"><span class="section-number-3">6.4</span> Inline caches for PCL </h3>
<div class="outline-text-3" id="text-6.4">

</div>

</div>

<div id="outline-container-6.5" class="outline-3">
<h3 id="sec-6.5"><span class="section-number-3">6.5</span> clang(++)-based FFI </h3>
<div class="outline-text-3" id="text-6.5">

</div>

</div>

<div id="outline-container-6.6" class="outline-3">
<h3 id="sec-6.6"><span class="section-number-3">6.6</span> MPFR for long floats </h3>
<div class="outline-text-3" id="text-6.6">

</div>

</div>

<div id="outline-container-6.7" class="outline-3">
<h3 id="sec-6.7"><span class="section-number-3">6.7</span> Structured codewalking </h3>
<div class="outline-text-3" id="text-6.7">

</div>

</div>

<div id="outline-container-6.8" class="outline-3">
<h3 id="sec-6.8"><span class="section-number-3">6.8</span> Hygienic macros </h3>
<div class="outline-text-3" id="text-6.8">

</div>

</div>

<div id="outline-container-6.9" class="outline-3">
<h3 id="sec-6.9"><span class="section-number-3">6.9</span> Precompilation support for CLOS </h3>
<div class="outline-text-3" id="text-6.9">

</div>

</div>

<div id="outline-container-6.10" class="outline-3">
<h3 id="sec-6.10"><span class="section-number-3">6.10</span> CLOS sealing </h3>
<div class="outline-text-3" id="text-6.10">


</div>

</div>

<div id="outline-container-6.11" class="outline-3">
<h3 id="sec-6.11"><span class="section-number-3">6.11</span> GCed special variables </h3>
<div class="outline-text-3" id="text-6.11">

</div>

</div>

<div id="outline-container-6.12" class="outline-3">
<h3 id="sec-6.12"><span class="section-number-3">6.12</span> Precise stack scanning </h3>
<div class="outline-text-3" id="text-6.12">

<p>The garbage collector used by SBCL on x86, x86-64 and threaded PPC is
conservative: any aligned word on the control stack or in a register
that might be a tagged pointer is treated as a potential root.
Consequently, some definite roots are treated as potential ones,
preventing some heap compaction, and spurious potential roots cause
spurious memory leaks.  Being able to partition some stack values as
definite references, non-references, and potential references would
greatly alleviate this issue.  
</p>
</div>

</div>

<div id="outline-container-6.13" class="outline-3">
<h3 id="sec-6.13"><span class="section-number-3">6.13</span> A binary serialisation library </h3>
<div class="outline-text-3" id="text-6.13">

<p>Many applications depend on the efficient (both in terms of time and
of space) serialisation of data.  A few Common Lisp libraries address
this concern portably, and "fasl" files offer very powerful
serialisation to files.  Exploiting implementation-specific knowledge
and placing restriction on serialised data enables an efficient wire
protocol.  Such a wire protocol would enable applications to
efficiently exchange or store data (and even code) between programs,
SBCL versions, or, potentially, platforms.
</p></div>

</div>

<div id="outline-container-6.14" class="outline-3">
<h3 id="sec-6.14"><span class="section-number-3">6.14</span> Contracts </h3>
<div class="outline-text-3" id="text-6.14">

</div>

</div>

<div id="outline-container-6.15" class="outline-3">
<h3 id="sec-6.15"><span class="section-number-3">6.15</span> Core relocation </h3>
<div class="outline-text-3" id="text-6.15">

</div>

</div>

<div id="outline-container-6.16" class="outline-3">
<h3 id="sec-6.16"><span class="section-number-3">6.16</span> Reducing the size of delivered applications </h3>
<div class="outline-text-3" id="text-6.16">

<p>Applications built with SBCL tend to be distributed as source or as
monolithic "images", snapshots of the managed heap.  Though they may
be compressed, image files are rather large: they include a complete
development system, including the compiler.  The size of applications
could be reduced by either distributing changes from a base image, or
by allowing users to enable more aggressive garbage collection when
saving images.  In order to complete this project, a student would
identify a promising approach, implement it, and exhibit practical
benefits in terms of image size.
</p>
</div>

</div>

<div id="outline-container-6.17" class="outline-3">
<h3 id="sec-6.17"><span class="section-number-3">6.17</span> Unboxed calling convention </h3>
<div class="outline-text-3" id="text-6.17">

</div>

</div>

<div id="outline-container-6.18" class="outline-3">
<h3 id="sec-6.18"><span class="section-number-3">6.18</span> Allocation pools </h3>
<div class="outline-text-3" id="text-6.18">

</div>

</div>

<div id="outline-container-6.19" class="outline-3">
<h3 id="sec-6.19"><span class="section-number-3">6.19</span> Shared memory multi-process heap </h3>
<div class="outline-text-3" id="text-6.19">

</div>

</div>

<div id="outline-container-6.20" class="outline-3">
<h3 id="sec-6.20"><span class="section-number-3">6.20</span> Faster FASL loading </h3>
<div class="outline-text-3" id="text-6.20">

</div>

</div>

<div id="outline-container-6.21" class="outline-3">
<h3 id="sec-6.21"><span class="section-number-3">6.21</span> Scheduling pass </h3>
<div class="outline-text-3" id="text-6.21">


</div>

</div>

<div id="outline-container-6.22" class="outline-3">
<h3 id="sec-6.22"><span class="section-number-3">6.22</span> utf-8b </h3>
<div class="outline-text-3" id="text-6.22">


</div>

</div>

<div id="outline-container-6.23" class="outline-3">
<h3 id="sec-6.23"><span class="section-number-3">6.23</span> Parametric recursive types </h3>
<div class="outline-text-3" id="text-6.23">

</div>
</div>
</div>
<div id="postamble">
<p class="date"> Date: 2013-03-29 23:59:54 CET</p>
</div>
</div>
</body>
</html>
