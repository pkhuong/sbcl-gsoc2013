#+OPTIONS: author:nil email:nil creator:nil
#+TITLE: Project Ideas

* Unicode Integration
SBCL has a simple-minded implementation of Unicode support: each
Unicode codepoint is a single Lisp character, and strings are
sequences of codepoints. This implementation meets the principle of
least surprise, but has left some rough edges; the project here
involves exploring some of those rough edges and smoothing them
down. The project involves: implementation and testing (from test
vectors and differentially) of a number of Unicode algorithms, and
(the interesting bit) integrating those algorithms in a tasteful way
in the language runtime: for example, by using the normalization
algorithm in symbol equality, allowing easy use of collation keys for
sorting, or syllable breaking in the pretty-printer or formatter.

** Deliverables
1. CL implementations of algorithms specified in the Unicode standards;
2. Integration of these algorithms into the the SBCL language runtime;
3. Integration of test cases into the SBCL build sequence;
4. Exploratory work in /using/ these algorithms in suitable places in
   the Lisp language runtime.

** Prerequisites
There are no hard prerequisites for this project; an interest in
internationalization issues would be helpful, as would prior
experience with working with Unicode.

** Student learning
A student successfully executing this project would learn about: data
structures for efficient information storage; test methodologies; and
working within the strictures of standardized algorithms and
languages.

* Exploiting GMP for bignum and rational arithmetic
SBCL has a reasonably simple but decent implementation of arbitrary
precision integers and rationals; its design is also informed by the
Common Lisp specification, in particular support for bitwise operation
in two's complement.  GNU MP (GMP) offers sophisticated routines that
would be extremely useful when working with medium and large bignums
or rationals, but calls to GMP entails conversion to/from
sign-magnitude representation, and foreign function interface
overhead.  The project requires the integration of GMP in SBCL,
ideally as an optional module ("contrib"), the development of
efficient conversion algorithms between GMP's and SBCL's concrete
representations, and the determination of cross-over points between
SBCL's and GMP's routines.  This work would probably be appreciated by
symbolic computing applications (e.g. maxima).

** Deliverables
1. (partial) Foreign function interface definitions for GMP;
2. Development of routines to convert between two's complement and
   sign-magnitude representation;
3. Integration in SBCL's existing bignum and rational arithmetic code;
4. Determination of criteria for the use of GMP's routines to improve
   performance on large integer or rationals, as used in applications,
   without overly penalising the common case of tiny values;
5. Development of unit tests for the new routines;
6. Improvement of SBCL's algorithms for small or medium bignums and
   rationals (optional).

** Prerequisites
Familiarity with Common Lisp or C. An interest in number theory would
be useful, and may provide additional motivation.

** Student learning
The student would learn to characterise the use of a small part of a
system (bignum and rational arithmetic) by various applications, and
develop microbenchmarks accordingly, in order to make non-obvious
technical decisions.  They would also exercise test methodologies, and
potentially implement algorithms described by specialised scientific
literature.

* A binary serialisation library
Many applications depend on the efficient (both in terms of time and
of space) serialisation of data.  A few Common Lisp libraries address
this concern portably, and "fasl" files offer very powerful
serialisation to files.  Exploiting implementation-specific knowledge
and placing restriction on serialised data enables an efficient wire
protocol.  Such a wire protocol would enable applications to
efficiently exchange or store data (and even code) between programs,
SBCL versions, or, potentially, platforms.

** Deliverables
1. Implementation of serialisation and deserialisation code for simple
   data (arrays, lists, hash tables, etc.);
2. Implementation of serialisation and deserialisation code for
   structures, CLOS objects, functions and closures;
3. Tests and benchmarks for the newly-developed code;
4. Clear and unambiguous definition of the serialisation format;
5. (partial) Reimplementation in fully portable Common Lisp (optional);
6. Serialisation format that minimises copying during deserialisation;
7. Serialisation format that allows files to be directly mapped in the
   heap (optional);
8. Compression-aware serialisation format (optional).

** Prerequisites
Familiarity with the concrete representation of data, at a C or
assembly level.  A working knowledge of Common Lisp and of
benchmarking methodologies can be acquired as needed.  Clear writing
would be a definite advantage.

** Student learning
The student would explore and develop strategies to traverse large
object graphs on contemporary architectures that strongly penalise
random access to main memory and to disk.  They would also investigate
trade-offs between the efficiency of serialisation and
de-serialisation, and integrate their code in a large working system.
Finally, they would demonstrate strong technical writing skills by
providing the definition for a new format.

* Flexible (pseudo) random number generation
SBCL's support for random number generation is limited to an
implementation of the Mersenne Twister (MT19937) PRNG.  This is a good
general-purpose PRNG, but some applications require different
characteristics of the random numbers, whether that is specific
guarantees about correlations, suitability for cryptographic
algorithms, or just plain raw speed.  This project involves
implementing several PRNG algorithms, and integrating them into SBCL
in such a way as to allow library authors and end-users to
programmatically negotiate the choice of PRNG algorithm among multiple
implemented choices.

** Deliverables
1. Implementations of several classes of random number generators,
   including one statistically-robust PRNG, geared toward demanding
   mathematical applications, and one believed suitable for
   cryptographic applications;
2. Use of statistical tests to examine the properties of the
   implemented PRNGs;
3. Pluggable integration into SBCL's existing random number generation
   code (using random-state objects);
4. (optional) support for hardware random number generators;
5. (optional) development of a protocol to allow random number
   generators to be selected dynamically given algorithmic
   requirements.

** Prerequisites
No strict prerequisites, although some understanding of the possible
space of pseudorandom number generation, including tradeoffs regarding
speed, predictability (forwards and backwards) and dimensional
distribution.  Familiarity with CL and its approach to random number
generation can be acquired while doing the project.

** Student learning
The student will learn the breadth of possible implementations of
random number generators, and their limitations, all while working in
the context of an established language runtime.  A successful project
is also likely to cover statistical tests of randomness and efficient
object-oriented design.

* Improving the thread-safety of the object system
Developers continually attempt to reduce SBCL's reliance on a single
"world" lock.  This effort has lead to the elimination of some
re-entrancy issues, and to the introduction of a few concurrency bugs,
many of them related to the Common Lisp Object System (CLOS).  Some
bugs are easily triggered, other depend on rare race conditions.  Some
could be fixed with additional lockings, others through the use of
mostly non-blocking synchronisation techniques, and others still by
outright modifying the behaviour of the object system.  This project
requires the student to organise known or potential concurrency bugs
in PCL, SBCL's implementation of CLOS, and attempt to fix them.

** Deliverables
1. Collect, organise, and diagnose concurrency bugs in PCL;
2. Fix some of these bugs;
3. Develop a methodology to trigger hard-to-detect concurrency bugs in
   PCL;
4. Suggest generally-applicable techniques to eliminate such bugs from
   PCL and the runtime system (optional).

** Prerequisites
Basic understanding of shared-memory concurrency.  A conservative
understanding of specific memory models will be developed in parallel
with the work.

** Student learning
The student will encounter concurrency bugs in a complex stateful
system that exploits both lock-based concurrency control and lock-free
operations.  They will develop an understanding for the issues
encountered in such systems, and learn how to detect and then solve
them.

* Reducing the size of delivered applications
Applications built with SBCL tend to be distributed as source or as
monolithic "images", snapshots of the managed heap.  Though they may
be compressed, image files are rather large: they include a complete
development system, including the compiler.  The size of applications
could be reduced by either distributing changes from a base image, or
by allowing users to enable more aggressive garbage collection when
saving images.  In order to complete this project, a student would
identify a promising approach, implement it, and exhibit practical
benefits in terms of image size.

* Quick compilation
SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
straightforward compilation, an intermediate choice between the
current extremes of a full type-propagating compiler and an
s-expression interpreter.  If completed, this project would enable
time-consuming phases of the compiler to be disabled or replaced with
coarser, but more quickly-executed, ones.  This would result in
reduced compilation times for code that isn't performance-critical,
and, potentially, the ability to compile very large computer-generated
functions.

** Deliverables
1. Identify the most time-consuming phases of the compiler;
2. Extend performance and correctness tests for the compiler;
3. Determine how to disable or simplify time-consuming phases, while
   preserving correctness;
4. (optional) Develop alternatives for a few recursive or super-linear
   computations in the compilation process.

** Prerequisites
No strict prerequisite. An interest in compilation would be helpful,
as would familiarity with the analysis and design of algorithms and
data structures.  The student will become comfortable with set and
lattice theory.

** Student learning
The student will gather representative code samples from actual users,
and exploit them to build an understanding of the empiric performance
of SBCL's compiler.  They will also use this data to develop
benchmarks that reflect real-world needs, and design tests to convince
themselves and others that changes to a large system preserve its
correctness.  They will finally exploit these tools to determine which
parts of the compiler should be disabled or simplified, and how to do
so.

* Efficient interpretation
SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
efficient interpretation, an intermediate choice between the current
extremes of a full type-propagating compiler and an s-expression
interpreter.  Completion of this project entails the development of a
standard-compliant minimal compiler.

** Deliverables
1. Disentangle or replicate the front-end to perform minimal
   compilation;
2. Define an intermediate representation appropriate for the
   efficient interpretation of Common Lisp code;
3. Develop a compiler from minimally-compiled source to the
   intermediate representation.

** Prerequisite
Familiarity with Lisp macros and with first-class functions.

** Student learning
The student would improve their ability to read, understand, and
implement an ANSI standard.  They would then explore the performance
of a few standard or novel interpretation schemes on contemporary
computers.  Finally, they would develop a small compiler for a
practical programming language.

* More efficient hash functions and hash tables
As mandated by the standard, SBCL offers hash tables and exposes
pre-defined hash functions.  Interactions with other parts of the
system make it challenging to improve general-purpose hash tables.
However, type-specialised hash tables seem approachable, as does
improving the quality of the standard hash functions.  If completed,
this project would lead to the implementation of better hash
functions, standard or as extensions, and to the development of
specialised associative dictionaries.

** Deliverables
1. Adapt and implement known families of hash functions for integer
   and string data;
2. Improve the distribution of standard hash functions;
3. Implement routines to test the quality and correctness of hash
   functions;
4. Provide parameterised hash functions that are resistant to
   collision attacks, as extensions to the standard;
5. Implement specialised associative dictionaries.

** Prerequisite
Familiarity with probabilities and with basic data structures.  An
interest in computer microarchitecture will be useful.

** Student learning
The student would exploit or implement state of the art hash
functions, compare their strengths and weaknesses, and integrate them
in a complete system.  They would also apply their understanding of
the low-level representation of data to develop specialised data
structures that remain compatible with a specification.

* An expression optimisation pass
Although SBCL performs fairly sophisticated analyses, subsequent
transformations are performed (except for a few exception) bottom-up,
one function call at a time.  A large body of classic techniques is
available to optimise complete (side-effect-free) expression trees
top-down.  Upon completion, this project would extend SBCL with a
system to define tree rewriting rules, and execute them on code.
Arithmetic and bitwise operations would likely benefit, as would
modular arithmetic and embedded domain-specific languages.
 
** Deliverables
1. Detection and visualisation of expression trees in the first
   intermediate representation (IR1);
2. Insertion of a top-down rewriting pass in the IR1 optimisation
   loop;
3. Development of a pattern and transform definition language for
   expression trees;
4. Implementation of a few rewrites with this new infrastructure.

** Prerequisite
Basic discrete mathematics.  Familiarity with formal grammars and
automata theory is optional.

** Student learning
The student would improve their understanding of the compilation
process for pure expressions, and review, then implement, classic
techniques for their improvement.  They would also develop a new
internal library feature, and exploit it to show concrete improvements
in the compiler's output.

* Exploiting switch/case in standard control structures
While Common Lisp exposes case constructs, there is no standard
support for constant-time computed goto or C-style switch/case flow
control.  A partial patch to extend SBCL with such an
indirect-jump-based control construct exists.  First, it must be
completed and tested, and, second, the new construct should be
exploited in a standard-compliant manner in the implementation of
standard flow control macros.  This project would greatly improve the
performance of some state machines implementations, and benefit to a
wide range of programs that use standard case constructs directly.
  
** Deliverable
1. Forward-port the indirect-jump patch;
2. Expose the new operator in a standard-compliant manner;
3. Create benchmarks to understand how to best use this new operator;
4. Exploit the operator in the implementation of standard flow control
   macros;
5. (optional) For the patch to additional computer architectures.

** Prerequisites
Knowledge of x86[-64] assembly language. Familiarity with advanced
compilation techniques is an advantage.

** Student learning
The student would gain an overview of the complete pipeline in a
production compiler, from the front-end, to dataflow analyses, to the
generation of machine code.  They would also have to work within an
ISO standard to expose a new feature to users.  Finally, they would
improve their understanding of the low-level performance of modern
architectures, particularly at the level of branch prediction, in
order to transparently improve the runtime efficiency of flow control
constructs.

* Peephole optimisation
Most of the cleverness in SBCL is in the front-end.  Once Common Lisp
has been lowered to an explicitly-typed C-level intermediate
representation, very few analyses and optimisations are performed,
when compared to other compilers.  As a result, clearly suboptimal
code sequences are generated, particularly at the boundary between two
operations.  A peephole optimisation pass would detect such sequences
and eliminate them or replace them with more efficient code.  This
could be achieved by considering sequences of instructions or of
virtual operations (instruction templates), or even by reconstructing
a tree from virtual operations.  The project would implement such a
peephole pass, offer a modular way to define new patterns, and add a
few such patterns for commonly-used architectures.

** Deliverables
1. Determine how to inject ad hoc rewrites during the emission of
   machine code;
2. Implement a simple, specialised, optimisation using that mechanism;
3. Develop a pattern-definition language appropriate for the chosen
   rewriting mechanism;
4. Implement some rewrites using that pattern-definition language, and
   show improvements in some degenerate cases.

** Prerequisites
Familiarity with assembly language in at least one platform supported
by SBCL.

** Student learning
The student will have evaluated how to best extend a system in a
direction that was not considered during its initial design.  They
will also review various approaches to improve code generation at a
low level, and create a new domain-specific language that will be used
by others.  They will finally develop code to detect and improve code
at the assembly level.

* Precompilation support for CLOS

* Exploiting vector intrinsics in block sequence operations
SBCL is finally gaining support for x86-64 short vector SIMD
instructions (SSE), at the source level.  Many array and sequence
processing functions would benefit from manual vectorisation.  If
successful, this project would require the identification of manual
vectorisation targets, the development of efficient routines, and the
addition of code and of transformations in the compiler to exploit
these routines transparently.

** Deliverables
1. A list of promising vectorisable operations;
2. The implementation of a few special cases for such vectorisable
   operations;
3. A generic method to dispatch to vectorised routines depending on
   the CPU's capabilities;
4. (optional) Convenience macros and functions to implement complete
   vectorised operations, including misaligned data;
5. (optional) SIMD-within-a-register (SWAR) implementations for some
   vectoriable routines.

** Prerequisites
Understanding of the bit-level representation of data in computers.
Familiarity with SSE instructions is expected to improve with time.

** Student learning
The student will learn to detect opportunities for vectorisation in
pre-existing code.  They will also improve their ability to adapt
algorithms to vector processing, and develop methods to determine when
and how operations should be vectorised.

* Modernising a graph-colouring register allocator
Variables are mapped to registers or stack locations in SBCL with a
straightforward graph-colouring allocator.  Graph colouring is a
well-known combinatorial optimisation problem, and, although it is
NP-Hard, some heuristic methods are known to perform very well in
practice.  Exploiting such methods in the register allocator would
enable code to avoid spills when register pressure is high; this is a
particularly pressing issue on x86.  Moreover, while SBCL's register
allocator allocates registers (or stack slots) to variables,
contemporary allocator obtain much better results by mapping registers
to values, thus allowing the values associated with a single variable
to be stored in different locations at distinct points in the code.
This can be achieved to a lesser extent by more closely tracking
values within a single basic block and by splitting live ranges in
multiple sections, if compensation code is inserted as needed.
Through any of these means, the project would improve the performance
of code that exhibits high register pressure.

** Deliverables
1. Accumulate a few functions that exhibit register allocation issues;
2. Improve the graph-colouring heuristic by adapting well-known
   methods;
3. Allocate registers more finely within a single basic block;
4. (optional) Implement a live-range splitting pass;
5. (optional) Exploit register-register exchange instructions to
   enable SSA-style register allocation.

** Prerequisites
Basic familiarity with assembly language. Some knowledge of discrete
mathematics and of graph theory.

** Student learning
The student will apply sophisticated heuristics to solve an NP-Hard
problem.  They will also learn to map abstract discrete optimisation
concepts to concrete low-level concepts such as architectural
registers and assembly instructions, and develop specialised methods
that straddle the two views to exploit domain-specific knowledge.

* Selecting concrete representations cleverly
An essential trick to SBCL's performance is its ability to represent
the same data in multiple manners, as boxed values, or as
machine-native values, e.g. signed or unsigned words, or floating
point values in registers.  However, not all operations have the same
requirements: some, like arbitrary calls, are better served with boxed
values, while others, like floating-point arithmetic, are more
efficient on natively-represented values.  SBCL currently assigns a
single concrete representation for each variable.  This selection
algorithm can be revisited and improved, but the constraints under
which it operates could be relaxed as well: nothing prevents a
variable's values to be represented in different manners at distinct
program points, as long as conversion code is inserted at key
locations.  In particular, this additional leeway imposes a very low
overhead if it is only exploited within each basic block.  This
project requires creativity to understand an exotic combinatorial
optimisation problem and determine how best to tackle it and adapt
existing methods; if successful, it would likely result in the
development of a novel algorithm for a problem essential to the
performance of dynamically-typed languages, and its application in a
pre-existing compiler, thus showing clear practical improvement.

** Deliverables
1. Describe the objective and constraints in the representation
   selection problem;
2. Reduce the representation selection problem to better understood
   optimisation problems with efficient heuristics;
3. Improve the currently-existing representation selection heuristic;
4. (optional) Implement value-based representation selection within
   basic blocks;
5. (optional) Implement SSA-style representation selection, with
   conversion code at control flow fork/join points.

** Prerequisites
Basic familiarity with assembly language. Some knowledge of discrete
mathematics and of graph theory.

** Student learning
The student will learn to describe a complicated, industrial,
combinatorial optimisation problem formally, and to reduce it to
classic optimisation problems.  They will then have an opportunity to
exploit this theoretical basis to improve on an existing heuristic, in
practice.  Finally, they will be lead to iteratively improve that
formal model to better represent the actual problem, while ensuring
the existence of efficient solving methods.

* Allocation pools

* Replacing the garbage collector with MPS
SBCL's garbage collector is well-modularised, but shares code only
with CMUCL, and suffers from a rigid design.  Ravenbrook's Memory Pool
System (MPS) is a flexible, high-performance, open source memory
management subsystem, and SBCL would likely gain in performance and in
robustnessby replacing its specialised garbage collector with MPS,
augmented with SBCL-specific extensions.  If successful, this project
would deeply integrate a complex library in a large system by
characterising their respective requirements and judiciously inserting
logic to make the two designs compatible.
  
** Deliverable
1. Description of the interface between SBCL's runtime and its memory
   management subsystem;
2. Stand-alone program that interfaces with MPS and presents
   challenges similar to that of SBCL (tagged pointers, several types
   of weaknesses, some data layout described by normal heap objects,
   ability to load a heap from disk, etc.);
3. Port the stand-alone program's design to SBCL, for a single
   platform;
4. (optional) Determine which pools are better suited to Common Lisp,
   and how to expose that choice to users.
5. (optional) Port SBCL/MPS to several platforms.

** Prerequisites
Knowledge of C and understanding of operating systems internals.

** Student learning
The student will become familiar with the memory management subsystem
used in a managed language that supports OS threads, and with the
internals of a state of the art garbage collector.  They will then
gain experience with the integration of independently-developed
systems.  They will also interface directly with the operating systems
as required for the development of a performance-oriented runtime
system.

* A hybrid copying/mark-and-sweep garbage collector
SBCL's garbage collector is a mostly-copying generational garbage
collector (gencgc).  Heap sizes have grown by multiple orders of
magnitude since the era when gencgc was designed.  It now seems
interesting to only use a copying garbage collector for
newly-allocated data, and to reduce writes to older data by performing
major collections with a mark-and-sweep pass.  Depending on the
student's affinity, this may prove to be less work or more interesting
than integrating a third-party design.  Completion of this project
entails the development of a memory management subsystem, including
difficult software development choices.  The result would be
improvements in the responsiveness and throughput of a production
language implementation.

** Deliverables
1. Description of the interface between SBCL's runtime and its memory
   management subsystem;
2. Implementation of mark-and-sweep in a distinct heap from the
   current copying one, with eviction from the copying heap to the
   mark-and-sweep heap;
3. Integration of the mark-and-sweep heap with the copying heap and
   its data structures;
4. (optional) Adaptation of mark-and-sweep GC to efficiently load
   images and to save less fragmented images;
5. (optional) Improved performance on read-mostly data.

** Prerequisites
Knowledge of C and understanding of operating systems internals. 

** Student learning
The student will appreciate the challenges faced by the
implementations of languages with managed memory.  They will
understand the theory of classic garbage collection and memory
management algorithms, and implement them.  They will also develop
code that interacts directly with the operating system in order to
manage resources efficiently.

* Software write barriers

* Efficient integer truncate/floor/ceiling by constants

* Scheduling pass

* Modified structure layout

* Precise stack scanning

* Coarser type derivation system

* CLOS sealing

* Unboxed calling convention

* Improving SBCL's memory allocator

Avoid interleaving boxed/unboxed pages, stop misaligning large
objects, colour them so they don't alias.

* utf-8b

* Free-er form displaced arrays

* Accurate type derivation
Look for an LFP instead of starting at T.
* Faster FASL loading
* Accurate and correct numeric type derivation
* Contracts
* Parametric recursive types
* MPFR for long floats
* clang(++)-based FFI
* Threading/locking debugging facilities
* Heap predicates and GC debugging
* Core relocation
* Better failure modes for heap overflow
Flexible heap, and GC before allocating.
* Shared memory multi-process heap
* Hygienic macros
* Structured codewalking
* Inline caches for PCL
* Autodxification of higher-order functions
* GCed special variables
