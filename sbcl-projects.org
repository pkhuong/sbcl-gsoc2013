#+OPTIONS: author:nil email:nil creator:nil
#+TITLE: Project Ideas

* Unicode Integration
SBCL has a simple-minded implementation of Unicode support: each
Unicode codepoint is a single Lisp character, and strings are
sequences of codepoints. This implementation meets the principle of
least surprise, but has left some rough edges; the project here
involves exploring some of those rough edges and smoothing them
down. The project involves: implementation and testing (from test
vectors and differentially) of a number of Unicode algorithms, and
(the interesting bit) integrating those algorithms in a tasteful way
in the language runtime: for example, by using the normalization
algorithm in symbol equality, allowing easy use of collation keys for
sorting, or syllable breaking in the pretty-printer or formatter.

** Deliverables
1. CL implementations of algorithms specified in the Unicode standards;
2. Integration of these algorithms into the the SBCL language runtime;
3. Integration of test cases into the SBCL build sequence;
4. Exploratory work in /using/ these algorithms in suitable places in
   the Lisp language runtime.

** Prerequisites
There are no hard prerequisites for this project; an interest in
internationalization issues would be helpful, as would prior
experience with working with Unicode.

** Student learning
A student successfully executing this project would learn about: data
structures for efficient information storage; test methodologies; and
working within the strictures of standardized algorithms and
languages.

* Exploiting GMP for bignum and rational arithmetic
SBCL has a reasonably simple but decent implementation of arbitrary
precision integers and rationals; its design is also informed by the
Common Lisp specification, in particular support for bitwise operation
in two's complement.  GNU MP (GMP) offers sophisticated routines that
would be extremely useful when working with medium and large bignums
or rationals, but calls to GMP entails conversion to/from
sign-magnitude representation, and foreign function interface
overhead.  The project requires the integration of GMP in SBCL,
ideally as an optional module ("contrib"), the development of
efficient conversion algorithms between GMP's and SBCL's concrete
representations, and the determination of cross-over points between
SBCL's and GMP's routines.  This work would probably be appreciated by
symbolic computing applications (e.g. maxima).

** Deliverables
1. (partial) Foreign function interface definitions for GMP;
2. Development of routines to convert between two's complement and
   sign-magnitude representation;
3. Integration in SBCL's existing bignum and rational arithmetic code;
4. Determination of criteria for the use of GMP's routines to improve
   performance on large integer or rationals, as used in applications,
   without overly penalising the common case of tiny values;
5. Development of unit tests for the new routines;
6. Improvement of SBCL's algorithms for small or medium bignums and
   rationals (optional).

** Prerequisites
Familiarity with Common Lisp and C. An interest in number theory would
be useful, and may provide additional motivation.

** Student learning
The student would learn to characterise the use of a small part of a
system (bignum and rational arithmetic) by various applications, and
develop microbenchmarks accordingly, in order to make non-obvious
technical decisions.  They would also exercise test methodologies, and
potentially implement algorithms described by specialised scientific
literature.

* A binary serialisation library
Many applications depend on the efficient (both in terms of time and
of space) serialisation of data.  A few Common Lisp libraries address
this concern portably, and "fasl" files offer very powerful
serialisation to files.  Exploiting implementation-specific knowledge
and placing restriction on serialised data enables an efficient wire
protocol.  

* Improving the thread-safety of the object system

* Reducing the size of delivered applications

* Quicker compilation

* More efficient hash functions and hash tables

* An expression optimisation pass

* Exploiting switch/case in standard control structures

* Peephole optimisation

* Precompilation support for CLOS

* Exploiting vector intrinsics in block sequence operations

* Modernising a graph-coloring register allocator

* Selecting concrete representations cleverly

* Allocation pools

* Replacing the garbage collector with MPS

* A hybrid copying/mark-and-sweep garbage collector

* Software write barriers

* Efficient integer truncate/floor/ceiling by constants

* Scheduling pass

* Modified structure layout

* Precise stack scanning

* Coarser type derivation system

* CLOS sealing

* Unboxed calling convention

* Improving SBCL's memory allocator

Avoid interleaving boxed/unboxed pages, stop misaligning large
objects, colour them so they don't alias.

* utf-8b

* Free-er form displaced arrays

* Flexible (pseudo) random number generation

* Accurate type derivation
