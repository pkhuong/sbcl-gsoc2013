#+OPTIONS: author:nil email:nil creator:nil
#+TITLE: Project Ideas

* Unicode Integration
SBCL has a simple-minded implementation of Unicode support: each
Unicode codepoint is a single Lisp character, and strings are
sequences of codepoints. This implementation meets the principle of
least surprise, but has left some rough edges; the project here
involves exploring some of those rough edges and smoothing them
down. The project involves: implementation and testing (from test
vectors and differentially) of a number of Unicode algorithms, and
(the interesting bit) integrating those algorithms in a tasteful way
in the language runtime: for example, by using the normalization
algorithm in symbol equality, allowing easy use of collation keys for
sorting, or syllable breaking in the pretty-printer or formatter.

** Deliverables
1. CL implementations of algorithms specified in the Unicode standards;
2. Integration of these algorithms into the the SBCL language runtime;
3. Integration of test cases into the SBCL build sequence;
4. Exploratory work in /using/ these algorithms in suitable places in
   the Lisp language runtime.

** Prerequisites
There are no hard prerequisites for this project; an interest in
internationalization issues would be helpful, as would prior
experience with working with Unicode.

** Student learning
A student successfully executing this project would learn about: data
structures for efficient information storage; test methodologies; and
working within the strictures of standardized algorithms and
languages.

* Exploiting GMP for bignum and rational arithmetic
SBCL has a reasonably simple but decent implementation of arbitrary
precision integers and rationals; its design is also informed by the
Common Lisp specification, in particular support for bitwise operation
in two's complement.  GNU MP (GMP) offers sophisticated routines that
would be extremely useful when working with medium and large bignums
or rationals, but calls to GMP entails conversion to/from
sign-magnitude representation, and foreign function interface
overhead.  The project requires the integration of GMP in SBCL,
ideally as an optional module ("contrib"), the development of
efficient conversion algorithms between GMP's and SBCL's concrete
representations, and the determination of cross-over points between
SBCL's and GMP's routines.  This work would probably be appreciated by
symbolic computing applications (e.g. maxima).

** Deliverables
1. (partial) Foreign function interface definitions for GMP;
2. Development of routines to convert between two's complement and
   sign-magnitude representation;
3. Integration in SBCL's existing bignum and rational arithmetic code;
4. Determination of criteria for the use of GMP's routines to improve
   performance on large integer or rationals, as used in applications,
   without overly penalising the common case of tiny values;
5. Development of unit tests for the new routines;
6. Improvement of SBCL's algorithms for small or medium bignums and
   rationals (optional).

** Prerequisites
Familiarity with Common Lisp or C. An interest in number theory would
be useful, and may provide additional motivation.

** Student learning
The student would learn to characterise the use of a small part of a
system (bignum and rational arithmetic) by various applications, and
develop microbenchmarks accordingly, in order to make non-obvious
technical decisions.  They would also exercise test methodologies, and
potentially implement algorithms described by specialised scientific
literature.

* A binary serialisation library
Many applications depend on the efficient (both in terms of time and
of space) serialisation of data.  A few Common Lisp libraries address
this concern portably, and "fasl" files offer very powerful
serialisation to files.  Exploiting implementation-specific knowledge
and placing restriction on serialised data enables an efficient wire
protocol.  Such a wire protocol would enable applications to
efficiently exchange or store data (and even code) between programs,
SBCL versions, or, potentially, platforms.

** Deliverables
1. Implementation of serialisation and deserialisation code for simple
   data (arrays, lists, hash tables, etc.);
2. Implementation of serialisation and deserialisation code for
   structures, CLOS objects, functions and closures;
3. Tests and benchmarks for the newly-developed code;
4. Clear and unambiguous definition of the serialisation format;
5. (partial) Reimplementation in fully portable Common Lisp (optional);
6. Serialisation format that minimises copying during deserialisation;
7. Serialisation format that allows files to be directly mapped in the
   heap (optional);
8. Compression-aware serialisation format (optional).

** Prerequisites
Familiarity with the concrete representation of data, at a C or
assembly level.  A working knowledge of Common Lisp and of
benchmarking methodologies can be acquired as needed.  Clear writing
would be a definite advantage.

** Student learning
The student would explore and develop strategies to traverse large
object graphs on contemporary architectures that strongly penalise
random access to main memory and to disk.  They would also investigate
trade-offs between the efficiency of serialisation and
de-serialisation, and integrate their code in a large working system.
Finally, they would demonstrate strong technical writing skills by
providing the definition for a new format.

* Flexible (pseudo) random number generation
SBCL's support for random number generation is limited to an
implementation of the Mersenne Twister (MT19937) PRNG.  This is a good
general-purpose PRNG, but some applications require different
characteristics of the random numbers, whether that is specific
guarantees about correlations, suitability for cryptographic
algorithms, or just plain raw speed.  This project involves
implementing several PRNG algorithms, and integrating them into SBCL
in such a way as to allow library authors and end-users to
programmatically negotiate the choice of PRNG algorithm among multiple
implemented choices.

** Deliverables
1. Implementations of several classes of random number generators,
   including one statistically-robust PRNG, geared toward demanding
   mathematical applications, and one believed suitable for
   cryptographic applications;
2. Use of statistical tests to examine the properties of the
   implemented PRNGs;
3. Pluggable integration into SBCL's existing random number generation
   code (using random-state objects);
4. (optional) support for hardware random number generators;
5. (optional) development of a protocol to allow random number
   generators to be selected dynamically given algorithmic
   requirements.

** Prerequisites
No strict prerequisites, although some understanding of the possible
space of pseudorandom number generation, including tradeoffs regarding
speed, predictability (forwards and backwards) and dimensional
distribution.  Familiarity with CL and its approach to random number
generation can be acquired while doing the project.

** Student learning
The student will learn the breadth of possible implementations of
random number generators, and their limitations, all while working in
the context of an established language runtime.  A successful project
is also likely to cover statistical tests of randomness and efficient
object-oriented design.

* Improving the thread-safety of the object system
Developers continually attempt to reduce SBCL's reliance on a single
"world" lock.  This effort has lead to the elimination of some
re-entrancy issues, and to the introduction of a few concurrency bugs,
many of them related to the Common Lisp Object System (CLOS).  Some
bugs are easily triggered, other depend on rare race conditions.  Some
could be fixed with additional lockings, others through the use of
mostly non-blocking synchronisation techniques, and others still by
outright modifying the behaviour of the object system.  This project
requires the student to organise known or potential concurrency bugs
in PCL, SBCL's implementation of CLOS, and attempt to fix them.

** Deliverables
1. Collect, organise, and diagnose concurrency bugs in PCL;
2. Fix some of these bugs;
3. Develop a methodology to trigger hard-to-detect concurrency bugs in
   PCL;
4. Suggest generally-applicable techniques to eliminate such bugs from
   PCL and the runtime system (optional).

** Prerequisites
Basic understanding of shared-memory concurrency.  A conservative
understanding of specific memory models will be developed in parallel
with the work.

** Student learning
The student will encounter concurrency bugs in a complex stateful
system that exploits both lock-based concurrency control and lock-free
operations.  They will develop an understanding for the issues
encountered in such systems, and learn how to detect and then solve
them.

* Reducing the size of delivered applications
Applications built with SBCL tend to be distributed as source or as
monolithic "images", snapshots of the managed heap.  Though they may
be compressed, image files are rather large: they include a complete
development system, including the compiler.  The size of applications
could be reduced by either distributing changes from a base image, or
by allowing users to enable more aggressive garbage collection when
saving images.  In order to complete this project, a student would
identify a promising approach, implement it, and exhibit practical
benefits in terms of image size.

* Quick compilation
SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
straightforward compilation, an intermediate choice between the
current extremes of a full type-propagating compiler and an
s-expression interpreter.  If completed, this project would enable
time-consuming phases of the compiler to be disabled or replaced with
coarser, but more quickly-executed, ones.  This would result in
reduced compilation times for code that isn't performance-critical,
and, potentially, the ability to compile very large computer-generated
functions.

** Deliverables
1. Identify the most time-consuming phases of the compiler;
2. Extend performance and correctness tests for the compiler;
3. Determine how to disable or simplify time-consuming phases, while
   preserving correctness;
4. (optional) Develop alternatives for a few recursive or super-linear
   computations in the compilation process.

** Prerequisites
No strict prerequisite. An interest in compilation would be helpful,
as would familiarity with the analysis and design of algorithms and
data structures.  The student will become comfortable with set and
lattice theory.

** Student learning
The student will gather representative code samples from actual users,
and exploit them to build an understanding of the empiric performance
of SBCL's compiler.  They will also use this data to develop
benchmarks that reflect real-world needs, and design tests to convince
themselves and others that changes to a large system preserve its
correctness.  They will finally exploit these tools to determine which
parts of the compiler should be disabled or simplified, and how to do
so.

* Efficient interpretation
SBCL inherited from CMUCL a complicated compilation process geared
toward the generation of efficient machine code.  A simple interpreter
enables SBCL to avoid this overhead in contexts when execution speed
is not an issue at all.  Many programs would benefit from more
efficient interpretation, an intermediate choice between the current
extremes of a full type-propagating compiler and an s-expression
interpreter.  Completion of this project entails the development of a
standard-compliant minimal compiler.

** Deliverables
1. Disentangle or replicate the front-end to perform minimal
   compilation;
2. Define an intermediate representation appropriate for the
   efficient interpretation of Common Lisp code;
3. Develop a compiler from minimally-compiled source to the
   intermediate representation.

** Prerequisite
Familiarity with Lisp macros and with first-class functions.

** Student learning
The student would improve their ability to read, understand, and
implement an ANSI standard.  They would then explore the performance
of a few standard or novel interpretation schemes on contemporary
computers.  Finally, they would develop a small compiler for a
practical programming language.

* More efficient hash functions and hash tables
As mandated by the standard, SBCL offers hash tables and exposes
pre-defined hash functions.  Interactions with other parts of the
system make it challenging to improve general-purpose hash tables.
However, type-specialised hash tables seem approachable, as does
improving the quality of the standard hash functions.  If completed,
this project would lead to the implementation of better hash
functions, standard or as extensions, and to the development of
specialised associative dictionaries.

** Deliverables
1. Adapt and implement known families of hash functions for integer
   and string data;
2. Improve the distribution of standard hash functions;
3. Implement routines to test the quality and correctness of hash
   functions;
4. Provide parameterised hash functions that are resistant to
   collision attacks, as extensions to the standard;
5. Implement specialised associative dictionaries.

** Prerequisite
Familiarity with probabilities and with basic data structures.  An
interest in computer microarchitecture will be useful.

** Student learning
The student would exploit or implement state of the art hash
functions, compare their strengths and weaknesses, and integrate them
in a complete system.  They would also apply their understanding of
the low-level representation of data to develop specialised data
structures that remain compatible with a specification.

* An expression optimisation pass
Although SBCL performs fairly sophisticated analyses, subsequent
transformations are performed (except for a few exception) bottom-up,
one function call at a time.  A large body of classic techniques is
available to optimise complete (side-effect-free) expression trees
top-down.  Upon completion, this project would extend SBCL with a
system to define tree rewriting rules, and execute them on code.
Arithmetic and bitwise operations would likely benefit, as would
modular arithmetic and embedded domain-specific languages.
 
** Deliverables
1. Detection and visualisation of expression trees in the first
   intermediate representation (IR1);
2. Insertion of a top-down rewriting pass in the IR1 optimisation
   loop;
3. Development of a pattern and transform definition language for
   expression trees;
4. Implementation of a few rewrites with this new infrastructure.

** Prerequisite
Basic discrete mathematics.  Familiarity with formal grammars and
automata theory is optional.

** Student learning
The student would improve their understanding of the compilation
process for pure expressions, and review, then implement, classic
techniques for their improvement.  They would also develop a new
internal library feature, and exploit it to show concrete improvements
in the compiler's output.

* Exploiting switch/case in standard control structures
While Common Lisp exposes case constructs, there is no standard
support for constant-time computed goto or C-style switch/case flow
control.  A partial patch to extend SBCL with such an
indirect-jump-based control construct exists.  First, it must be
completed and tested, and, second, the new construct should be
exploited in a standard-compliant manner in the implementation of
standard flow control macros.  This project would greatly improve the
performance of some state machines implementations, and benefit to a
wide range of programs that use standard case constructs directly.
  
** Deliverable
1. Forward-port the indirect-jump patch;
2. Expose the new operator in a standard-compliant manner;
3. Create benchmarks to understand how to best use this new operator;
4. Exploit the operator in the implementation of standard flow control
   macros;
5. (optional) For the patch to additional computer architectures.

** Prerequisites
Knowledge of x86[-64] assembly language. Familiarity with advanced
compilation techniques is an advantage.

** Student learning
The student would gain a partial comprehension of the complete
pipeline in a production compiler, from the front-end, to dataflow
analyses, to the generation of machine code.  They would also have to
work within an ISO standard to expose a new feature to users.
Finally, they would improve their understanding of the low-level
performance of modern architectures, particularly at the level of
branch prediction, in order to transparently improve the runtime
efficiency of flow control constructs.

* Peephole optimisation


* Precompilation support for CLOS

* Exploiting vector intrinsics in block sequence operations

* Modernising a graph-coloring register allocator

* Selecting concrete representations cleverly

* Allocation pools

* Replacing the garbage collector with MPS

* A hybrid copying/mark-and-sweep garbage collector

* Software write barriers

* Efficient integer truncate/floor/ceiling by constants

* Scheduling pass

* Modified structure layout

* Precise stack scanning

* Coarser type derivation system

* CLOS sealing

* Unboxed calling convention

* Improving SBCL's memory allocator

Avoid interleaving boxed/unboxed pages, stop misaligning large
objects, colour them so they don't alias.

* utf-8b

* Free-er form displaced arrays

* Accurate type derivation
Look for an LFP instead of starting at T.
* Faster FASL loading
* Accurate and correct numeric type derivation
* Contracts
* Parametric recursive types
* MPFR for long floats
* clang(++)-based FFI
* Threading/locking debugging facilities
* Heap predicates and GC debugging
* Core relocation
* Better failure modes for heap overflow
Flexible heap, and GC before allocating.
* Shared memory multi-process heap
* Hygienic macros
* Structured codewalking
* Inline caches for PCL
* Autodxification of higher-order functions
* GCed special variables
